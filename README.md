# Отчёт
---
## Замеры [здесь](https://drive.google.com/drive/folders/1h-tbP_xnionJwpWfB0F-ihF1Rc0Gd5Jn?usp=sharing)
---
# Код формирования таблиц
---
## Первый вариант формирования таблицы
* ***A[i][j] == (N/M * i + j) * 2***

```python
  mat = [[0] * strin_len for i in range(col_len)]
  for i in range(col_len):
      for k in range(strin_len):
          if i == 0 and k == 0:
              mat[i][k] = 0
          else:
              mat[i][k] = int((strin_len/col_len*i+k)*2)
```
### Для запуска программы с первым формированием таблицы нужно запустить файл [main.py](https://github.com/ThisisFinee/Algo1_lab/blob/5428f1dfdc3e2beeb6ade80086641fc2fb3a143d/main.py)
## Второй вариант формирования таблицы
* ***A[i][j] == (N/M * i * j) * 2***

```python
  mat = [[0] * strin_len for i in range(col_len)]
  for i in range(col_len):
      for k in range(strin_len):
          if i == 0 and k == 0:
              mat[i][k] = 0
          else:
              mat[i][k] = int((strin_len/col_len*i*k)*2)
```
### Для запуска программы со вторым формированием таблицы нужно запустить файл [main2.py](https://github.com/ThisisFinee/Algo1_lab/blob/5428f1dfdc3e2beeb6ade80086641fc2fb3a143d/main2.py)
---
# Код реализации алгоритмов
---
## Поиск лесенкой

```python
def ladder_search(a, m, n, el):
    no_res = False
    n1 = 0
    m1 = m - 1
    elem = [-1, -1, -1]
    while elem != el or no_res != True:
        if a[n1][m1] < el and n1 < n - 1:
            n1 += 1
        elif a[n1][m1] > el and m1 > 0:
            m1 -= 1
        elif a[n1][m1] == el:
            elem = [el, n1, m1]
            break
        else:
            no_res = True
            break
    return elem
```
### Сложность: O(M+N)
### Алгоритм находится в файле [ladder_search.py](https://github.com/ThisisFinee/Algo1_lab/blob/5428f1dfdc3e2beeb6ade80086641fc2fb3a143d/ladder_search.py)
### Идея реализации: 
  #### Начальная позиция - правый верхний угол, если элемент поиска больше выбранного, то делаем шаг вниз по матрице, если элемент поиска меньше, то делаем шаг влево по матрице. Действуем таким образом либо пока не пройдём по всем строкам или столбцам, либо пока не найдём элемент.
---
## Двоичный поиск

```python
def bisec_search(meta, item):  # default binary search
    low, high = 0, len(meta)
    while low < high:
        mid = (low+high) // 2
        mid_val = meta[mid]
        if item > mid_val:
            low = low+1
        else:
            high = mid-1
    if meta[low] == item:
        return [meta[low]]
    else:
        return [-1]
```
### Сложность: O(M*log(N))
### Алгоритм находится в файле [bisec_search.py](https://github.com/ThisisFinee/Algo1_lab/blob/5428f1dfdc3e2beeb6ade80086641fc2fb3a143d/bisec_search.py)
### Идея реализации:
  #### Переводим матрицу(фактически двумерный массив) в одномерный массив(не считываем время на перевод, чтобы замерить именно время работы самого алгоритма), создаём три позиции low = начало массива, high = его конец, mid = (low+high)/2. Если элемент поиска больше элемента с индексом mid, то low+=1 и пересчитываем mid, если меньше high = mid-1 и пересчитываем mid, и так до тех пор пока low<high. Если элемент с индексом low равен элементу поиска, то возвращаем его в ином слуае возвращаем, что элемент не был найден.
---
## Экспоненциальный поиск
```python
def exp_search(meta, item):
    meta1 = []
    if meta[0] == item:
        return [1]
    ind = 1
    while meta[ind] < item:
        ind*=2
        if ind >= len(meta):
            ind = len(meta)-1
            if meta[ind] < item:
                return [-1]
            else:
                break
    return ind
```
### Сложность: O(M*log(N))
> #### Бинарый поиск(для экспоненциального)
> ```python
> def bis_search(lst, item):
>     low, high = 0, len(lst)
>     while low < high:
>         mid = (low + high) // 2
>         mid_val = lst[mid]
>         if item > mid_val:
>             low = low + 1
>         else:
>             high = mid - 1
>     if lst[low] == item:
>         return [lst[low]]
>     else:
>         return [-1]
> ```
### Оба алгоритма находятся в файле [exp_search.py](https://github.com/ThisisFinee/Algo1_lab/blob/5428f1dfdc3e2beeb6ade80086641fc2fb3a143d/exp_search.py)
### Идея реализации: 
  #### Переводим матрицу(фактически двумерный массив) в одномерный массив(не считываем время на перевод, чтобы замерить именно время работы самого алгоритма), проверяем нулевой элемент массива(так как для удобства идём с первого), если он не равен элементу поиска, то запускаем алгоритм, создаём позицию ind = 1, и при каждой итерации цикла умножаем эту позицию на 2(ind *= 2), цикл работает до тех пор пока элемент с индексом ind меньше элемента поиска или пока ind < len(array)(в этом случае проверяем последний элемент массива, если он меньше, то выводим что элемента поиска нет, если он больше то запускаем двоичный поиск на срез массива от ind//2 до len(array)), если же элемент поиска меньше выбранного элемента, то запускаем двоичный поиск от ind//2 до ind
---
# Код замера и вывода времени работы алгоритмов
---
## Поиск лесенкой

```python
start_time1 = time.process_time()
for k in range(1000):
    lad_res = ladder_search(mat, strin_len, col_len, target)
end_time1 = time.process_time()
lad_res.append((end_time1 - start_time1))
if lad_res[0] == -1:
    print(f"{j}.В результате поиска лесенкой элемент не был найден, время: {lad_res[3]}")
else:
    print(f"{j}.Поиск лесенкой.Элемент:{lad_res[0]}, строка:{lad_res[1]}, столбец:{lad_res[2]}, время:{lad_res[3]}")
```

### Разъеснение: Каждый алгоритм приходилось запускать 1000 раз, так как в ином случае измерить время было бы просто невозможно(оно всегда равнялось 0)
---
## Двоичный поиск

```python
start_time2 = time.process_time()
for k in range(1000):
    bis_res = bisec_search(meta, target)
end_time2 = time.process_time()
bis_res.append(end_time2 - start_time2)
if bis_res[0] == -1:
    print(f"{j}.В результате двоичного поиска элемент не был найден, время: {bis_res[1]}")
else:
    print(f"{j}.Двоичный поиск.Элемент:{bis_res[0]} был найден, время:{bis_res[1]}")
```
---
## Экспоненциальный поиск

```python
start_time3 = time.process_time()
        for i in range(1000):
            ind = exp_search(meta, target)
        end_time3 = time.process_time()
        start_time4 = time.process_time()
        n = meta[ind // 2:ind]
        for i in range(1000):
            exp_res = bis_search(n, target)
        end_time4 = time.process_time()
        exp_res.append((end_time3 - start_time3)+(end_time4 - start_time4))
        if exp_res[0] == -1:
            print(f"{j}.В результате экспоненциального поиска элемент не был найден, время: {exp_res[1]}")
        else:
            print(f"{j}.Экспоненциальный поиск.Элемент:{exp_res[0]}, был найден, время:{exp_res[1]}")
```

### Разъеснение: для того чтобы не формировать срез 1000 раз(так как это очень долго и в корне меняет результаты по времени), схема замера приобрела такой вид(сначала с помощью экспоненциального поиска находим индекс, после чего создаём на его основе срез и прогоняем его двоичным поиском)

---
# Таблицы и графики замеров
---
## Первый вариант формирования матрицы

* Таблица(Данные представлены в секундах)

![image](https://github.com/ThisisFinee/Algo1_lab/blob/2df8901e358d8d9a1dfeded6b02f2242d334379b/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA%20%D0%B2%D0%B0%D1%801.png)

* График

![image](https://github.com/ThisisFinee/Algo1_lab/blob/2df8901e358d8d9a1dfeded6b02f2242d334379b/%D0%BF%D0%BE%D0%B8%D1%81%D0%BA%20%D0%B2%D0%B0%D1%801-%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D0%BA.png)

## Итог: На маленьких данных поиск лесенкой куда более эфективный чем двоичный, однако при больших данных поиск лесенкой работает либо хуже, либо немного быстрее(разные варианты при нескольких запусках), экспоненциальный же является самым эффективным как на больших так и на маленьких данных(не сильно меняется), связано это с тем что он быстрее остальных пробегает весь массив данных, а так как элемента который мы ищем не существует в массиве, то на этом он останавливается.

---

## Второй вариант формирования матрицы

* Таблицы(данные представлены в секундах)

![image](https://github.com/ThisisFinee/Algo1_lab/blob/2df8901e358d8d9a1dfeded6b02f2242d334379b/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA%20%D0%B2%D0%B0%D1%802.png)

* График

![image](https://github.com/ThisisFinee/Algo1_lab/blob/2df8901e358d8d9a1dfeded6b02f2242d334379b/%D0%9F%D0%BE%D0%B8%D1%81%D0%BA%20%D0%B2%D0%B0%D1%802%20-%20%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D0%BA.png)

## Итог: На маленьких данных поиск лесенкой и двоичный поиск практически не отличаются по эффективности(поиск лесенкой всё таки немного быстрее), на больших же данных двоичный поиск начинает работать очень долго из-за чего поиск лесенкой выглядит куда более эфективным, экспоненциальный же при таком формировании матрицы работает ещё быстрее чем при другом(он является куда как более эффективным чем остальные алгоритмы и в этом варианте формирования матрицы), а изменения от данных всё такие же несущественные(как бы я не старался понять с чем связано ускорение по сравнению с другим вариантом формирования таблицы, у меня так и не вышло) 

---

# Итог: самый эффективный алгоритм поиска из представленных - экспоненциальный, менее эффективным является поиск лесенкой(на больших данных в первом варианте формирования матрицы показывал себя примерно также как и двоичный, и на маленьких данных во втором варианте был очень близок к нему), и самым не эффективным является двоичный поиск(во втором варианте на больших данных показывал очень большое время работы)
